/**
 * Advanced 2D Graphics Engine for Pocket Monsters - Stake.com Edition
 * Enhanced with WebGL shaders, particle systems, and casino-quality animations
 */

export interface PokemonSymbol {
  id: string;
  name: string;
  tier: number;
  texture: WebGLTexture;
  animationFrames: WebGLTexture[];
  rarity: 'common' | 'rare' | 'epic' | 'legendary';
  glowColor: [number, number, number];
  particleEffect?: string;
}

export interface GraphicsConfig {
  canvas: HTMLCanvasElement;
  gridSize: { rows: number; cols: number };
  cellSize: { width: number; height: number };
  animationSpeed: number;
  particleCount: number;
  qualitySettings: 'low' | 'medium' | 'high' | 'ultra';
}

export class AdvancedGraphicsEngine {
  private gl!: WebGL2RenderingContext;
  private programs: Map<string, WebGLProgram> = new Map();
  private textures: Map<string, WebGLTexture> = new Map();
  private framebuffers: Map<string, WebGLFramebuffer> = new Map();
  
  // Animation and effects systems
  private animationQueue: Animation[] = [];
  private particleSystem: ParticleSystem;
  private postProcessor: PostProcessor;
  private audioManager: AudioManager;
  
  // Performance optimization
  private objectPool: ObjectPool;
  private renderBatches: RenderBatch[] = [];
  private lastFrameTime = 0;
  private deltaTime = 0;

  constructor(private config: GraphicsConfig) {
    this.initWebGL();
    this.loadShaders();
    this.initSystems();
  }

  private initWebGL() {
    const gl = this.config.canvas.getContext('webgl2', {
      antialias: true,
      alpha: false,
      depth: true,
      stencil: true,
      powerPreference: 'high-performance'
    });
    
    if (!gl) throw new Error('WebGL2 not supported');
    this.gl = gl as WebGL2RenderingContext;

    // Enable advanced features
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.depthFunc(gl.LEQUAL);
  }

  private initSystems() {
    // Initialize stub subsystems so referencing methods won't throw during headless builds
    this.particleSystem = new ParticleSystem(this.gl);
    this.postProcessor = new PostProcessor(this.gl);
    this.audioManager = new AudioManager();
    this.objectPool = new ObjectPool();
  }

  private loadShaders() {
    // Load all shader programs for different effects
    this.loadSymbolShader();
    this.loadParticleShader();
    this.loadGlowShader();
    this.loadCascadeShader();
    this.loadMultiplierShader();
    this.loadPostProcessShader();
  }

  private loadSymbolShader() {
    const vertexShader = `#version 300 es
      precision highp float;
      
      in vec2 a_position;
      in vec2 a_texCoord;
      in float a_rotation;
      in vec2 a_scale;
      in float a_glow;
      
      uniform mat4 u_projection;
      uniform mat4 u_view;
      uniform float u_time;
      
      out vec2 v_texCoord;
      out float v_glow;
      out float v_pulse;
      
      void main() {
        // Apply rotation and scaling
        mat2 rotation = mat2(
          cos(a_rotation), -sin(a_rotation),
          sin(a_rotation), cos(a_rotation)
        );
        
        vec2 scaledPos = a_position * a_scale;
        vec2 rotatedPos = rotation * scaledPos;
        
        // Add subtle floating animation
        float floatOffset = sin(u_time * 2.0 + rotatedPos.x * 0.1) * 0.02;
        rotatedPos.y += floatOffset;
        
        gl_Position = u_projection * u_view * vec4(rotatedPos, 0.0, 1.0);
        v_texCoord = a_texCoord;
        v_glow = a_glow;
        v_pulse = sin(u_time * 3.0) * 0.5 + 0.5;
      }
    `;

    const fragmentShader = `#version 300 es
      precision highp float;
      
      in vec2 v_texCoord;
      in float v_glow;
      in float v_pulse;
      
      uniform sampler2D u_texture;
      uniform vec3 u_glowColor;
      uniform float u_time;
      uniform float u_brightness;
      
      out vec4 fragColor;
      
      void main() {
        vec4 texColor = texture(u_texture, v_texCoord);
        
        // Apply glow effect
        vec3 glow = u_glowColor * v_glow * v_pulse;
        vec3 finalColor = texColor.rgb + glow;
        
        // Add brightness variation for rarity
        finalColor *= u_brightness;
        
        // Premium quality alpha blending
        fragColor = vec4(finalColor, texColor.a);
      }
    `;

    const program = this.createProgram(vertexShader, fragmentShader);
    this.programs.set('symbol', program);
  }

  private loadParticleShader() {
    const vertexShader = `#version 300 es
      precision highp float;
      
      in vec2 a_position;
      in vec2 a_velocity;
      in float a_life;
      in float a_size;
      in vec4 a_color;
      
      uniform mat4 u_projection;
      uniform float u_time;
      uniform float u_deltaTime;
      
      out vec4 v_color;
      out float v_life;
      
      void main() {
        vec2 pos = a_position + a_velocity * u_deltaTime;
        
        // Apply physics
        pos.y += -9.81 * u_deltaTime * u_deltaTime * 0.5; // gravity
        
        gl_Position = u_projection * vec4(pos, 0.0, 1.0);
        gl_PointSize = a_size * (a_life / 1.0);
        
        v_color = a_color;
        v_life = a_life;
      }
    `;

    const fragmentShader = `#version 300 es
      precision highp float;
      
      in vec4 v_color;
      in float v_life;
      
      out vec4 fragColor;
      
      void main() {
        vec2 coord = gl_PointCoord - vec2(0.5);
        float dist = length(coord);
        
        if (dist > 0.5) discard;
        
        float alpha = v_color.a * (1.0 - dist * 2.0) * v_life;
        fragColor = vec4(v_color.rgb, alpha);
      }
    `;

    const program = this.createProgram(vertexShader, fragmentShader);
    this.programs.set('particle', program);
  }

  private loadCascadeShader() {
    // Shader for cascade/tumbling animations with smooth interpolation
    const vertexShader = `#version 300 es
      precision highp float;
      
      in vec2 a_position;
      in vec2 a_startPos;
      in vec2 a_endPos;
      in float a_progress;
      
      uniform mat4 u_projection;
      uniform float u_cascadeProgress;
      
      out vec2 v_texCoord;
      
      // Smooth easing function
      float easeOutBounce(float t) {
        if (t < 1.0 / 2.75) {
          return 7.5625 * t * t;
        } else if (t < 2.0 / 2.75) {
          t -= 1.5 / 2.75;
          return 7.5625 * t * t + 0.75;
        } else if (t < 2.5 / 2.75) {
          t -= 2.25 / 2.75;
          return 7.5625 * t * t + 0.9375;
        } else {
          t -= 2.625 / 2.75;
          return 7.5625 * t * t + 0.984375;
        }
      }
      
      void main() {
        float easedProgress = easeOutBounce(clamp(u_cascadeProgress, 0.0, 1.0));
        vec2 currentPos = mix(a_startPos, a_endPos, easedProgress);
        
        gl_Position = u_projection * vec4(currentPos + a_position, 0.0, 1.0);
        v_texCoord = a_position * 0.5 + 0.5;
      }
    `;

    const fragmentShader = `#version 300 es
      precision highp float;
      
      in vec2 v_texCoord;
      uniform sampler2D u_texture;
      uniform float u_alpha;
      
      out vec4 fragColor;
      
      void main() {
        vec4 texColor = texture(u_texture, v_texCoord);
        fragColor = vec4(texColor.rgb, texColor.a * u_alpha);
      }
    `;

    const program = this.createProgram(vertexShader, fragmentShader);
    this.programs.set('cascade', program);
  }

  // Advanced multiplier visualization with dynamic effects
  private loadMultiplierShader() {
    const vertexShader = `#version 300 es
      precision highp float;
      
      in vec2 a_position;
      in float a_multiplier;
      in vec2 a_cellPos;
      
      uniform mat4 u_projection;
      uniform float u_time;
      uniform float u_intensity;
      
      out float v_multiplier;
      out vec2 v_cellPos;
      out float v_glow;
      
      void main() {
        // Pulsing effect based on multiplier value
        float pulse = sin(u_time * 4.0 + a_multiplier) * 0.1 + 1.0;
        vec2 scaledPos = a_position * pulse;
        
        gl_Position = u_projection * vec4(a_cellPos + scaledPos, 0.0, 1.0);
        
        v_multiplier = a_multiplier;
        v_cellPos = a_cellPos;
        v_glow = u_intensity;
      }
    `;

    const fragmentShader = `#version 300 es
      precision highp float;
      
      in float v_multiplier;
      in vec2 v_cellPos;
      in float v_glow;
      
      uniform float u_time;
      
      out vec4 fragColor;
      
      vec3 getMultiplierColor(float mult) {
        if (mult <= 2.0) return vec3(0.0, 1.0, 0.0);      // Green
        else if (mult <= 4.0) return vec3(0.0, 0.5, 1.0); // Blue
        else if (mult <= 8.0) return vec3(1.0, 0.5, 0.0); // Orange
        else if (mult <= 16.0) return vec3(1.0, 0.0, 0.5); // Pink
        else return vec3(1.0, 1.0, 0.0);                   // Gold
      }
      
      void main() {
        vec3 baseColor = getMultiplierColor(v_multiplier);
        
        // Add pulsing glow effect
        float pulse = sin(u_time * 6.0) * 0.3 + 0.7;
        vec3 finalColor = baseColor * pulse * v_glow;
        
        // Radial gradient for multiplier orb
        vec2 center = gl_PointCoord - vec2(0.5);
        float dist = length(center);
        float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
        
        fragColor = vec4(finalColor, alpha);
      }
    `;

    const program = this.createProgram(vertexShader, fragmentShader);
    this.programs.set('multiplier', program);
  }

  // Post-processing effects for premium visual quality
  private loadPostProcessShader() {
    const vertexShader = `#version 300 es
      precision highp float;
      
      in vec2 a_position;
      out vec2 v_texCoord;
      
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
        v_texCoord = a_position * 0.5 + 0.5;
      }
    `;

    const fragmentShader = `#version 300 es
      precision highp float;
      
      in vec2 v_texCoord;
      
      uniform sampler2D u_scene;
      uniform sampler2D u_bloom;
      uniform vec2 u_resolution;
      uniform float u_time;
      uniform float u_intensity;
      
      out vec4 fragColor;
      
      // Tone mapping for HDR-like quality
      vec3 ACESFilm(vec3 x) {
        float a = 2.51;
        float b = 0.03;
        float c = 2.43;
        float d = 0.59;
        float e = 0.14;
        return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);
      }
      
      void main() {
        vec3 scene = texture(u_scene, v_texCoord).rgb;
        vec3 bloom = texture(u_bloom, v_texCoord).rgb;
        
        // Combine scene and bloom
        vec3 color = scene + bloom * u_intensity;
        
        // Apply tone mapping
        color = ACESFilm(color);
        
        // Subtle vignette for focus
        vec2 center = v_texCoord - 0.5;
        float vignette = 1.0 - smoothstep(0.6, 1.4, length(center));
        color *= vignette;
        
        fragColor = vec4(color, 1.0);
      }
    `;

    const program = this.createProgram(vertexShader, fragmentShader);
    this.programs.set('postprocess', program);
  }

  private loadGlowShader() {
    const vertexShader = `#version 300 es
      precision highp float;
      
      in vec2 a_position;
      in vec2 a_texCoord;
      
      uniform mat4 u_projection;
      uniform vec2 u_offset;
      
      out vec2 v_texCoord;
      
      void main() {
        gl_Position = u_projection * vec4(a_position + u_offset, 0.0, 1.0);
        v_texCoord = a_texCoord;
      }
    `;

    const fragmentShader = `#version 300 es
      precision highp float;
      
      in vec2 v_texCoord;
      
      uniform sampler2D u_texture;
      uniform vec2 u_direction;
      uniform float u_strength;
      
      out vec4 fragColor;
      
      void main() {
        vec2 texelSize = 1.0 / textureSize(u_texture, 0);
        vec4 color = vec4(0.0);
        
        // Gaussian blur for glow effect
        float weights[5] = float[](0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);
        
        color += texture(u_texture, v_texCoord) * weights[0];
        
        for(int i = 1; i < 5; i++) {
          color += texture(u_texture, v_texCoord + u_direction * texelSize * float(i)) * weights[i];
          color += texture(u_texture, v_texCoord - u_direction * texelSize * float(i)) * weights[i];
        }
        
        fragColor = color * u_strength;
      }
    `;

    const program = this.createProgram(vertexShader, fragmentShader);
    this.programs.set('glow', program);
  }

  private createProgram(vertexSource: string, fragmentSource: string): WebGLProgram {
    const gl = this.gl;
    
    const vertexShader = this.createShader(gl.VERTEX_SHADER, vertexSource);
    const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentSource);
    
    const program = gl.createProgram()!;
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      const info = gl.getProgramInfoLog(program);
      gl.deleteProgram(program);
      throw new Error(`Program link error: ${info}`);
    }
    
    return program;
  }

  private createShader(type: number, source: string): WebGLShader {
    const gl = this.gl;
    const shader = gl.createShader(type)!;
    
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    
    if (!gl.getShaderParameter(shader, gl.COMPLETE_STATUS ?? gl.COMPILE_STATUS)) {
      const info = gl.getShaderInfoLog(shader);
      gl.deleteShader(shader);
      throw new Error(`Shader compile error: ${info}`);
    }
    
    return shader;
  }

  // Main rendering pipeline
  public render(gameState: any, timestamp: number) {
    const gl = this.gl;
    this.deltaTime = timestamp - this.lastFrameTime;
    this.lastFrameTime = timestamp;

    // Clear buffers
    gl.clearColor(0.0, 0.0, 0.1, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // Render main game scene
    this.renderGameGrid(gameState);
    this.renderMultipliers(gameState.multiplierMap);
    this.renderAnimations();
    
    // Render particle effects
    this.particleSystem.update(this.deltaTime);
    this.particleSystem.render();
    
    // Post-processing for premium quality
    this.postProcessor.process();
    
    // Update and render UI elements
    this.renderUI(gameState);
  }

  private renderAnimations() {
    // placeholder for animation queue processing in headless builds
  }

  private renderUI(_gameState: any) {
    // placeholder for UI composition in headless builds
  }

  private renderGameGrid(gameState: any) {
    const gl = this.gl;
    const program = this.programs.get('symbol')!;
    
    gl.useProgram(program);
    
    // Set common uniforms
    const timeUniform = gl.getUniformLocation(program, 'u_time');
    gl.uniform1f(timeUniform, this.lastFrameTime / 1000.0);
    
    // Render each symbol with appropriate effects
    for (let row = 0; row < this.config.gridSize.rows; row++) {
      for (let col = 0; col < this.config.gridSize.cols; col++) {
        const symbol = gameState.grid[row][col];
        if (symbol && symbol.id !== '__empty__') {
          this.renderSymbol(symbol, row, col, program);
        }
      }
    }
  }

  private renderSymbol(symbol: any, row: number, col: number, program: WebGLProgram) {
    const gl = this.gl;
    
    // Calculate screen position
    const x = col * this.config.cellSize.width;
    const y = row * this.config.cellSize.height;
    
    // Set symbol-specific uniforms
    const glowColorUniform = gl.getUniformLocation(program, 'u_glowColor');
    const brightnessUniform = gl.getUniformLocation(program, 'u_brightness');
    
    // Different visual treatment based on Pokemon rarity
    const pokemonData = this.getPokemonData(symbol.id);
    gl.uniform3f(glowColorUniform, pokemonData.glowColor[0], pokemonData.glowColor[1], pokemonData.glowColor[2]);
    gl.uniform1f(brightnessUniform, pokemonData.brightness);
    
    // Render the quad with the symbol texture
    this.drawQuad(x, y, this.config.cellSize.width, this.config.cellSize.height);
  }

  private renderMultipliers(multiplierMap: number[][]) {
    const gl = this.gl;
    const program = this.programs.get('multiplier')!;
    
    gl.useProgram(program);
    
    for (let row = 0; row < multiplierMap.length; row++) {
      for (let col = 0; col < multiplierMap[row].length; col++) {
        const multiplier = multiplierMap[row][col];
        if (multiplier > 0) {
          this.renderMultiplierEffect(multiplier, row, col, program);
        }
      }
    }
  }

  private renderMultiplierEffect(multiplier: number, row: number, col: number, _program: WebGLProgram) {
    // Minimal stub – a real implementation would draw a billboarded sprite or point
    // Here we could enqueue into renderBatches if needed. Kept as no-op for build safety.
  }

  // Enhanced cascade animation system
  public animateCascade(_removedCells: Array<[number, number]>, callback: () => void) {
    const duration = 800; // milliseconds
    const startTime = performance.now();
    
    const animate = (currentTime: number) => {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1.0);
      
      // Update cascade shader uniforms
      const program = this.programs.get('cascade')!;
      this.gl.useProgram(program);
      const progressUniform = this.gl.getUniformLocation(program, 'u_cascadeProgress');
      this.gl.uniform1f(progressUniform, progress);
      
      if (progress < 1.0) {
        requestAnimationFrame(animate);
      } else {
        callback();
      }
    };
    
    requestAnimationFrame(animate);
  }

  // Master Ball effect with spectacular visuals
  public triggerMasterBallEffect(_multiplier: number) {
    // Create explosion particle effect
    this.particleSystem.createExplosion({
      position: [this.config.canvas.width / 2, this.config.canvas.height / 2],
      color: [1.0, 1.0, 0.0, 1.0], // Gold
      particleCount: 200,
      velocity: 15.0,
      lifetime: 2.0
    });
    
    // Screen flash effect
    this.postProcessor.addFlashEffect(0.3, 300);
    
    // Audio cue
    this.audioManager.play('masterball_activate');
  }

  // Utility methods
  private getPokemonData(symbolId: string): { glowColor: [number, number, number]; brightness: number; rarity: string } {
    const pokemonDatabase: Record<string, { glowColor: [number, number, number]; brightness: number; rarity: string }> = {
      'pikachu': { glowColor: [1.0, 1.0, 0.0], brightness: 1.2, rarity: 'common' },
      'charmander': { glowColor: [1.0, 0.5, 0.0], brightness: 1.1, rarity: 'common' },
      'squirtle': { glowColor: [0.0, 0.5, 1.0], brightness: 1.1, rarity: 'common' },
      'bulbasaur': { glowColor: [0.0, 1.0, 0.0], brightness: 1.1, rarity: 'common' },
      'jigglypuff': { glowColor: [1.0, 0.5, 1.0], brightness: 1.3, rarity: 'rare' },
      'eevee': { glowColor: [0.8, 0.6, 0.4], brightness: 1.4, rarity: 'epic' },
      'wild': { glowColor: [1.0, 1.0, 1.0], brightness: 1.5, rarity: 'legendary' }
    };
    
    return pokemonDatabase[symbolId] || pokemonDatabase['pikachu'];
  }

  private drawQuad(x: number, y: number, width: number, height: number) {
    const gl = this.gl;
    
    const vertices = new Float32Array([
      x, y,
      x + width, y,
      x, y + height,
      x + width, y + height
    ]);
    
    const buffer = gl.createBuffer();
    if (!buffer) return;
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    gl.deleteBuffer(buffer);
  }

  // Performance monitoring
  public getPerformanceMetrics() {
    return {
      fps: this.deltaTime ? 1000 / this.deltaTime : 0,
      drawCalls: this.renderBatches.length,
      particleCount: this.particleSystem.getActiveParticles(),
      memoryUsage: this.getGPUMemoryUsage()
    };
  }

  private getGPUMemoryUsage(): number {
    // Estimate GPU memory usage
    const ext: any = this.gl.getExtension('WEBGL_debug_renderer_info');
    if (ext) {
      // const renderer = this.gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);
      // Implement memory estimation logic if needed
      return 0; // Placeholder
    }
    return 0;
  }
}

// Supporting classes for the graphics engine
class ParticleSystem {
  constructor(private gl: WebGL2RenderingContext, private maxParticles: number = 10000) {}
  
  update(_deltaTime: number) {
    // Update particle physics
  }
  
  render() {
    // Render all active particles
  }
  
  createExplosion(_config: any) {
    // Create explosion particle effect
  }
  
  getActiveParticles(): number {
    return 0; // Placeholder
  }
}

class PostProcessor {
  constructor(private gl: WebGL2RenderingContext) {}
  
  process() {
    // Apply post-processing effects
  }
  
  addFlashEffect(_intensity: number, _duration: number) {
    // Add screen flash effect
  }
}

class AudioManager {
  play(_soundId: string) {
    // Play audio with WebAudio API
  }
}

class ObjectPool {
  // Object pooling for performance optimization
}

class RenderBatch {
  // Batch rendering for optimal performance
}

interface Animation {
  type: string;
  duration: number;
  progress: number;
  target: any;
}